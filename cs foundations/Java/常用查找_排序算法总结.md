# 常用查找_排序算法总结

[TOC]



## 查找算法

### 顺序查找

### 二分查找

### 哈希表查找

### 二叉排序树查找



## 排序算法

### 插入排序

### 冒泡排序

### 归并排序



### 快速排序

#### 思路

快速排序是对冒泡排序的一种改进，其基本思想是基于分治法的。在待排序的序列中选取一个值作为一个基准值，按照这个基准值的大小将这个序列划分成两个子序列，基准值会在这两个子序列的中间，一边是比基准小的，另一边就是比基准大的。这样快速排序第一次排完，我们选取的这个基准值就会出现在它该出现的位置上。这就是快速排序的单趟算法，也就是完成了一次快速排序。然后再对这两个子序列按照同样的方法进行排序，直到只剩下一个元素或者没有元素的时候就停止，这时候所有的元素都出现在了该出现的位置上。

#### 代码

```java
public class Main{
    public int quickSort(int[] array, int start, int end){  //end是数组最后一个下标, 也就是array.length-1
        if(start < end){
            int i = partition(array, start, end);  
            quickSort(array, start, i-1)
            quickSort(array, i+1, end);
        }
    }
    
    //一次partition
    private int partition(int[] array, int low, int high){  // (排序区域包含array[high])
        int pivot = array[low];
        while(low < high){
       		while(high > low && array[high] >= pivot) high--;
            array[low] = array[high];    // 执行这一步时,要么high=low; 要么high>low, arry[high] < pivot;
        	while(high > low && array[low] <= pivot) low++;
        	array[high] = array[low];   // 同样, 执行这一步时,要么high=low; 要么high>low, arry[low] > pivot;
        }  // 循环结束时, 必然是high==low
        array[low] = pivot;
        return low;
    }
}
```

或者也可以这样写, 更加简练(推荐):

```
public class Main{
    public int quickSort(int[] array, int start, int end){  //end是数组最后一个下标, 也就是array.length-1
        if(start < end){
            int pivot = array[start];
            int low = start;
            int high = end;
            while(low < high){
                while(high > low && array[high] >= pivot) high--;
                array[low] = array[high];
                while(high > low && array[low] <= pivot) low++;
                array[high] = array[low];
            }
            array[low] = pivot;
            quickSort(array, start, low-1);
            quickSort(array, low+1, end);
        }
    }
}
```

while 当前后没有相遇时:

(step1)while 当前后没有相遇时: 从后往前,选择一个小于pivot的, 放到前面去;

(step2)while 当前后没有相遇时: 从前往后,选择一个大于pivot的, 放到后面去;

最后执行到哪一步跳出外层while循环?  step1和step2都有可能. 跳出外层while循环时, 必然有high==low, 且这个位置的元素,已经被转移走了. 所以可以将pivot放置到这里.