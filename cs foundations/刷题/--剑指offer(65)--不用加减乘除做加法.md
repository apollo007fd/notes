--剑指offer(65)--不用加减乘除做加法

题目: 写一个函数，求2个整数之和，要求在函数体内不得使用加减乘除四则运算符号。



题意分析：

不用加减乘除，只能使用位运算来模拟；

- 先以十进制加法为例：


假设15+7,  可以先对应的各位相加，不进位，得到12， 产生的进位为01，将01左移一位，得到10, 再将12和10相加，得到22。

- 如果是二进制: 

  1110 和 101相加:

做异或运算，得到1011；做位与运算，得到进位0100，进位左移1位，得到1000。

将1011和1000继续相加，做异或运算，得到0011；做位与运算，得到1000，将其左移一位，得到10000。

将0011和10000继续相加，做异或运算，得到10011，位与运算得到00000,位与的结果为0，循环结束，结果为10011。



不进位的1101是两个数的异或，java中(^)，进位的1000是两个数的位与向左移1位而得到。

结果就等于1101+1000；再继续重复上面步骤，直到进位等于0为止。

```
public int Add(int num1,int num2) {
        while(num2 != 0){
            int nor = num1 ^ num2;
            int and = num1 & num2;
            and = and << 1;
            num1 = nor;
            num2 = and;
        }
        return num1;
    }
```

java位运算总结：

|   按位与   |  &   |                                                              |
| :--------: | :--: | ------------------------------------------------------------ |
|  按位异或  |  ^   |                                                              |
|  按位取反  |  ~   |                                                              |
|   按位或   |  \|  |                                                              |
|    右移    |  >>  | 不改变正负，符号位不变。负数右移，数值位高位补1；正数右移，数值位高位补0；                eg.10...001  右移1位变成 10....00 |
| 无符号右移 | >>>  | 符号位和数值位整体右移；符号位补0，负数会变成正数，正数不可能变成负数；                     eg.10...001无符号右移1位变成01...00 |
|    左移    |  <<  | 符号位和数值位整体左移；低位补0；负数可能变成正数；正数也可能变成负数；             eg.10...001左移1位变成0...010 |
| 无符号左移 | <<<  | **没有这个运算，没有无符号左移，因为与左移运算效果一样**     |

逻辑算法： &&    ||   ！