# 二叉搜索树的后序遍历序列

![](data:image/jpeg;base64,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)

9.33

输入一个数组, 判断是不是二叉树的后序遍历序列

中序是有序序列 5-6-7-8-9-10-11

后序序列 5-7-6-9-11-10-8

10.16

算法思想:

二叉排序树的后序遍历序列, 最后一个节点是根节点root, 如果root有左子树, 则左子树序列一定小于root, 如果有右子树, 右子树序列一定大于root. 如果不满足这个条件, 则不是一颗二叉排序树的后序遍历序列.

二叉排序树的子树也是二叉排序树, 很明显可以用递归的方式来解.

```python
# -*- coding:utf-8 -*-
class Solution:
    def VerifySquenceOfBST(self, sers):
        if len(sers)==0:
            return False
        return self.VerifyHelper(sers)
    
    def VerifyHelper(self, sers):
        if len(sers)==0:
            return True
        root = sers[-1]
        i = -1
        while i+1<len(sers)-1 and sers[i+1] < root:
            i += 1
        j = i + 1
        while j < len(sers)-1:
            if sers[j] < root:
                return False
            j+=1
        return self.VerifyHelper(sers[:i+1]) and self.VerifyHelper(sers[j:-1])
```

